{
    "contents" : "#' Activity Summary--MVPA\n#'\n#' Summarize activity measures using MVPA\n#' @param final.dat cleaned final data that is between record getup time and sleep time\n\n#' @return Total.light.time Total light time: the total activity minutes minus the total MVPA hours\n#' @return Total.MVPA.time  Total MVPA hours: the summation of the total Long Bout MVPA and total Sporadic MVPA durations\n#' @return Total.MVPA.Long.Bout.time Total MVPA long bout time: the summation of the total Long Bout MVPA durations\n#' @return Total.MVPA.Sporadic.time Total MVPA sporadic time: the summation of the total Sporadic MVPA durations\n#' @return Total.Number.of.MVPA.Long.Bouts.and.Sporadic Total Number of MVPA (Long Bouts or Sporadic): count the number of MVPA from 15 second data\n#' @return Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2 Proportion of MVPA (Long Bouts or Sporadic) greater than 2 minutes\n#' @return Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5 Proportion of MVPA (Long Bouts or Sporadic) greater than 5 minutes\n#' @return Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10 Proportion of MVPA (Long Bouts or Sporadic) greater than 10 minutes\n#' @return Total.Number.of.MVPA.Long.Bouts Total number of long bout MVPA: count the number of Long Bouts MVPA from 10 minute data\n#' @return Mean.MVPA.Long.Bout.Length Mean of long bout MVPA length\n#' @return Proportion.of.MVPA.Long.Bouts.greater.10 Proportion of Long Bout MVPA greater than 10 minutes\n#' @return Proportion.of.MVPA.Long.Bouts.greater.20 Proportion of Long Bout MVPA greater than 20 minutes\n#' @return Highest.MET.value.15s Highest METs values in 15 second\n#' @return Highest.MET.value.10min Highest METs values in 10 minutes\n#' @return Total.MET.hrs.Long.Bouts.and.Sporadic.mvpa Total METs hours from Long Bout MVPA and sporadic MVPA: the summation of METs hours from all MVPA records\n#' @return Total.MET.hrs.Long.Bouts Total METs hours from Long Bout MVPA: the summation of METs hours from Long Bout MVPA records\n#' @details MVPA is defined into two types: Long Bout MVPA and Sporadic MVPA. Long Bout MVPA is defined as 10 consecutive minutes with METs>=3 (allowing 2 min below that threshold). Sporadic MVPA is defined as activities at any time with METS>=3 and they are not in Long Bout MVPA.\n#' @details Highest METs values in 15 second/10 minutes are calculated by picking up the maximum METs values from the combined data with 15 second intervals and the data with 10 minutes intervals, respectively.\n#' @examples data(sampledata);MVPA_summary(sampledata)\n#' @export\n\nMVPA_summary=function(final.dat)\n{\n\n\ndat=final.dat\nif(is.numeric(dat$Time)==F) ####if  is.numeric(dat$Time)==F, we need further modification of time in next step\n{\n  ee<-as.character(dat$Time)\n  max.length<-max(nchar(ee))\n  ee[nchar(ee)!=max.length]<-\"#1899-12-30 00:00:00#\"\n  #### use character type, may not be good\n  ee.new<- (as.numeric( as.POSIXlt( substr(ee, 2, max.length-1 )  )    )+2209190400)/24/60/60\n  #### use interval type, this is the best\n  start.ee<-  min(which(dat[,2]>0))-1\n  if (start.ee>1)\n  {\n    ee.new.int.type <-c( ee.new[1:((start.ee)-1)],ee.new[start.ee]+(dat$DataCount[start.ee:nrow(dat)]/10/24/60/60)  )\n  }else\n  {    ee.new.int.type <-ee.new[start.ee]+(dat$DataCount[start.ee:nrow(dat)]/10/24/60/60)\n  } #### if interval type has large difference with character type, use character type\n  int.dif.char<-which(abs(ee.new-ee.new.int.type)>0.1 )\n  ee.new.int.type[int.dif.char]<-ee.new[int.dif.char]\n  ####\n  dat<-cbind(ee.new.int.type,dat[,2:6])\n}\nfinal.dat<-dat[,c(1,3,4,6)]\ncolnames(final.dat)<-c(\"date.time\",\"Interval\",\"ActivityCode\", \"METs\")\nfinal.dat=subset(final.dat,date.time!=0.625) #delete rows with time as #1899-12-30 00:00:00#\ntemp.mat=final.dat\n\n\n\ntemp.mat.for.activity<- temp.mat\ntemp.mat.for.activity$Activity[temp.mat.for.activity$Activity==1]<-2\nend.pos<-cumsum(rle(temp.mat.for.activity$Activity)$lengths)\nstart.pos<-c(0,end.pos[1:(length(end.pos)-1)])+1\n############### for each runs, handle the data\nhandle.runs<- sapply(1:length(end.pos),function(x,data.mat=temp.mat.for.activity)\n{\n  select.data<-data.mat[start.pos[x]:end.pos[x],]\n  combine.data<- c(min(select.data$date.time),sum(select.data$Interval),max(select.data$Activity),sum(select.data$METs) )\n  return(combine.data)\n}, simplify=F\n)\n############### combine each run\ncombined.temp.mat.for.activity<-data.frame(do.call(rbind,handle.runs))\ncolnames(combined.temp.mat.for.activity)<-c(\"date.time\", \"Interval\", \"ActivityCode\",\"METs\")\n###############\n###############Calculation\n###############\n###\ntemp.activity<-subset(combined.temp.mat.for.activity,combined.temp.mat.for.activity$ActivityCode==2)$Interval\nmvpa.sporadic.interval<- 1/4          ### 1 means 1 minute; 0.5 means 30 seconds; 1/6 means 10 seconds\n\n\nmvpa.1min.mat<-temp.mat\nstart.time<-mvpa.1min.mat$date.time[1]\nend.time<-  mvpa.1min.mat$date.time[nrow(mvpa.1min.mat)]\nnum.1min.interval<- trunc( (end.time-start.time)*24*60*60/(60*mvpa.sporadic.interval) )   ###point 1\n#(end.time-start.time) != sum(temp.mat$Interval)/60/60/24 if there is take off\ninterval.length<-mvpa.sporadic.interval*60/60/60/24\ninterval.1min.start<-start.time+interval.length*(1:(num.1min.interval))\n##################\nmvpa.record.start.time<-c(start.time, interval.1min.start)\nmvpa.record.end.time<-c(interval.1min.start,end.time)\n################## if there is take off, they won't be in combine.original.pseudo.mat\ncombine.original.pseudo.mat<-do.call(rbind,sapply(1: length(mvpa.record.start.time),function(ll){\n  temp.mat<-subset(mvpa.1min.mat,mvpa.1min.mat[,1]+mvpa.1min.mat[,2]/24/60/60>mvpa.record.start.time[ll] & mvpa.1min.mat[,1]<mvpa.record.end.time[ll] )\n  if(nrow(temp.mat)==0) return (NULL)\n  if(temp.mat[nrow(temp.mat),1]+(temp.mat[nrow(temp.mat),2]/24/60/60)> mvpa.record.end.time[ll])  ###if this activity is the last one and it surpass the take off log time\n  {\n    temp.mat[nrow(temp.mat),4]<-temp.mat[nrow(temp.mat),4]*(mvpa.record.end.time[ll]-temp.mat[nrow(temp.mat),1])/(temp.mat[nrow(temp.mat),2]/24/60/60)\n    temp.mat[nrow(temp.mat),2]<- (mvpa.record.end.time[ll]-temp.mat[nrow(temp.mat),1])*24*60*60\n  }\n  if(temp.mat[1,1]<mvpa.record.start.time[ll])   ###if this activity is the first one and itis earlier than the take on log time\n  {\n    temp.mat[1,4]<-temp.mat[1,4]* (temp.mat[1,2]-(mvpa.record.start.time[ll]- temp.mat[1,1])*24*60*60)/temp.mat[1,2]\n    temp.mat[1,2]<-temp.mat[1,2]-(mvpa.record.start.time[ll]- temp.mat[1,1])*24*60*60\n    temp.mat[1,1]<-mvpa.record.start.time[ll]\n  }\n\n  return(cbind(temp.mat,ll))\n}, simplify = F)  )\n\ncolnames(combine.original.pseudo.mat)<-c(\"date.time\",\"Interval\",\"ActivityCode\", \"METs\",\"one.minute.interval\")\n############################################################\n############################################################ step2 summary 1 min intervals\n############################################################\none.minute.collection<-by(combine.original.pseudo.mat,combine.original.pseudo.mat$one.minute.interval,function(s)c(min(s$date.time),sum(s$METs)*(60/mvpa.sporadic.interval),unique(s$one.minute.interval),sum(s$Interval)  )) ###point 3\none.minute.mat<-do.call(rbind,one.minute.collection)\none.minute.mat<-subset(one.minute.mat,one.minute.mat[,3]!=0 & one.minute.mat[,4]>(60*mvpa.sporadic.interval*0.9) & one.minute.mat[,4]<(60*mvpa.sporadic.interval*1.1)     )  ### one.minute.mat[,4] is the true length, it may not be exactly 30 second, can have a few seconds bias\n#########################\nif(trunc(nrow(one.minute.mat)/(10/mvpa.sporadic.interval))==0)  {\n  ten.minute.vec<-rep(1,nrow(one.minute.mat))\n  if(nrow(one.minute.mat)==1) ten.minute.mat<- data.frame(t(c(one.minute.mat[1:length(ten.minute.vec),],ten.minute.vec)))\n  if(nrow(one.minute.mat)>1) ten.minute.mat<- data.frame(cbind(one.minute.mat[1:length(ten.minute.vec),],ten.minute.vec))\n} else\n{\n  ten.minute.vec<-rep(1:trunc(nrow(one.minute.mat)/(10/mvpa.sporadic.interval)),each=  (10/mvpa.sporadic.interval)    )    ##### 30s to 10 min ###point 4\n  ten.minute.mat<- data.frame(cbind(one.minute.mat[1:length(ten.minute.vec),],ten.minute.vec))\n}\n\ncolnames(ten.minute.mat)<-c(\"date.time\",\"mets\",\"one.minute.interval\",\"interval.length\",\"ten.minute.interval\")\n############################################################\n############################################################ step3 summary 10 min intervals\n############################################################\n#### if in 10 minutes, 8 minutes have METs>3, it is MVPA bout; if less than 8minutes, they are counted as mvpa sporadic.\nis.mvpa<-function(s) if(s>=(8/mvpa.sporadic.interval)    ) return(1) else return(0)   ###point 5  ### this is for MVPA long bout\nten.minute.collection<- data.frame(do.call(rbind,by(ten.minute.mat,ten.minute.mat$ten.minute.interval,function(s)c(min(s$date.time), is.mvpa(length(which(s$mets>=3))), mean(s$mets),length(which(s$mets>=3)), abs(max(s$date.time)-min(s$date.time)-sum(s$interval.length[1:(length(s$interval.length)-1)])/24/60/60 )   ))))\ncolnames(ten.minute.collection)<-c(\"date.time\",\"mvpa\",\"mets\",\"mvpa.sporadic\",\"is.interval.valid\")  #### is.interval.valid is to avoid the wear off during the day problem\nten.minute.collection<-subset(ten.minute.collection,is.interval.valid<0.003) ###if the interval has 5 minutes take off, we do not take it\n\n############################################################\n############################################################ step4 MVPA information\n############################################################\n#### total time\nTotal.MVPA.Long.Bout.time<-nrow(subset(ten.minute.collection,mvpa==1))/6  ###by hours\nTotal.MVPA.Sporadic.time<-sum(subset(ten.minute.collection,mvpa.sporadic>0 & mvpa!=1)$mvpa.sporadic )/(60/mvpa.sporadic.interval) ###by hours ###point 6\nTotal.MVPA.time<- Total.MVPA.Long.Bout.time+Total.MVPA.Sporadic.time\nTotal.light.time<- sum(temp.activity) /60/60-Total.MVPA.time\n#### Long Bouts+Sporadic.time runs\nLong.Bouts.and.Sporadic.run<- rle(ifelse( one.minute.mat[,2]>=3,1,0))\nTotal.Number.of.MVPA.Long.Bouts.and.Sporadic<-  length(which(Long.Bouts.and.Sporadic.run$values==1))\n\nrun.for.Long.Bouts.and.Sporadic.mvpa<- Long.Bouts.and.Sporadic.run$lengths[which(Long.Bouts.and.Sporadic.run$values==1)]/ (60/mvpa.sporadic.interval) ###by hours ###point 7\n\nif(Total.MVPA.time==0)  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2<-0 else  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2<-100*length(run.for.Long.Bouts.and.Sporadic.mvpa[run.for.Long.Bouts.and.Sporadic.mvpa>1/30])/Total.Number.of.MVPA.Long.Bouts.and.Sporadic\nif(Total.MVPA.time==0)  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5<-0 else  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5<-100*length(run.for.Long.Bouts.and.Sporadic.mvpa[run.for.Long.Bouts.and.Sporadic.mvpa>1/12])/Total.Number.of.MVPA.Long.Bouts.and.Sporadic\nif(Total.MVPA.time==0)  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10<-0 else Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10<-100*length(run.for.Long.Bouts.and.Sporadic.mvpa[run.for.Long.Bouts.and.Sporadic.mvpa>1/6])/Total.Number.of.MVPA.Long.Bouts.and.Sporadic\n\n\n#### Long Bouts Only runs\nrun.for.mvpa<-rle(ten.minute.collection$mvpa)\n\nTotal.Number.of.MVPA.Long.Bouts<-  length(which(run.for.mvpa$values==1))\ntemp.mvpa.long.bout<-run.for.mvpa$lengths[which(run.for.mvpa$values==1)]/6 ###by hours\nif(Total.Number.of.MVPA.Long.Bouts==0) Mean.MVPA.Long.Bout.Length<-0 else Mean.MVPA.Long.Bout.Length<-mean(temp.mvpa.long.bout)\n####\nif(Total.Number.of.MVPA.Long.Bouts==0)  Proportion.of.MVPA.Long.Bouts.greater.10<-0 else  Proportion.of.MVPA.Long.Bouts.greater.10<-100*length(temp.mvpa.long.bout[temp.mvpa.long.bout>1/6])/Total.Number.of.MVPA.Long.Bouts\nif(Total.Number.of.MVPA.Long.Bouts==0)  Proportion.of.MVPA.Long.Bouts.greater.20<-0 else  Proportion.of.MVPA.Long.Bouts.greater.20<-100*length(temp.mvpa.long.bout[temp.mvpa.long.bout>2/6])/Total.Number.of.MVPA.Long.Bouts\n#### percentile is not meaningful, always too short\n####if(Total.Number.of.MVPA.Long.Bouts==0)\n#### {\n####percentile.MVPA.Long.Bouts.time.5<- 0\n####percentile.MVPA.Long.Bouts.time.25<- 0\n####percentile.MVPA.Long.Bouts.time.50<- 0\n####percentile.MVPA.Long.Bouts.time.75<- 0\n####percentile.MVPA.Long.Bouts.time.95<- 0\n#### } else {\n####  Percentiles.of.MVPA.Long.Bout.Length.quantile<- quantile(temp.mvpa.long.bout, probs = c(0.05,0.25,0.5,0.75,0.95))\n####percentile.MVPA.Long.Bouts.time.5<- Percentiles.of.MVPA.Long.Bout.Length.quantile[1]\n####percentile.MVPA.Long.Bouts.time.25<- Percentiles.of.MVPA.Long.Bout.Length.quantile[2]\n####percentile.MVPA.Long.Bouts.time.50<- Percentiles.of.MVPA.Long.Bout.Length.quantile[3]\n####percentile.MVPA.Long.Bouts.time.75<- Percentiles.of.MVPA.Long.Bout.Length.quantile[4]\n####percentile.MVPA.Long.Bouts.time.95<- Percentiles.of.MVPA.Long.Bout.Length.quantile[5]\n####        }\n\n\n####################################################\n#################################################### MET.value\n####################################################\nHighest.MET.value.15s<- max(one.minute.mat[,2])\nHighest.MET.value.10min<- max(ten.minute.collection[,3])\n################################################ MET.value from MVPA\nTotal.MET.hrs.Long.Bouts.and.Sporadic.mvpa<- sum((one.minute.mat[,2]/60/60*one.minute.mat[,4])[one.minute.mat[,2]>=3])\nTotal.MET.hrs.Long.Bouts<- sum((subset(ten.minute.collection,mvpa==1))$mets/60*10)\n\n\ntable<- cbind(Total.light.time,Total.MVPA.time, Total.MVPA.Long.Bout.time,Total.MVPA.Sporadic.time,Total.Number.of.MVPA.Long.Bouts.and.Sporadic,Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2,Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5,Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10, Total.Number.of.MVPA.Long.Bouts,Mean.MVPA.Long.Bout.Length, Proportion.of.MVPA.Long.Bouts.greater.10,Proportion.of.MVPA.Long.Bouts.greater.20, Highest.MET.value.15s,Highest.MET.value.10min, Total.MET.hrs.Long.Bouts.and.Sporadic.mvpa,Total.MET.hrs.Long.Bouts)\ncolnames(table)<- c(\"Total.light.time\",\"Total.MVPA.time\",\"Total.MVPA.Long.Bout.time\",\"Total.MVPA.Sporadic.time\",\"Total.Number.of.MVPA.Long.Bouts.and.Sporadic\",\"Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2\",\"Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5\",\"Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10\",\"Total.Number.of.MVPA.Long.Bouts\",\"Mean.MVPA.Long.Bout.Length\",\"Proportion.of.MVPA.Long.Bouts.greater.10\",\"Proportion.of.MVPA.Long.Bouts.greater.20\",\"Highest.MET.value.15s\",\"Highest.MET.value.10min\",\"Total.MET.hrs.Long.Bouts.and.Sporadic.mvpa\",\"Total.MET.hrs.Long.Bouts\")\nout=list( Total.light.time=Total.light.time,Total.MVPA.time=Total.MVPA.time, Total.MVPA.Long.Bout.time=Total.MVPA.Long.Bout.time,Total.MVPA.Sporadic.time=Total.MVPA.Sporadic.time,Total.Number.of.MVPA.Long.Bouts.and.Sporadic=Total.Number.of.MVPA.Long.Bouts.and.Sporadic,Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2=Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2,Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5=Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5,Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10=Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10, Total.Number.of.MVPA.Long.Bouts=Total.Number.of.MVPA.Long.Bouts,Mean.MVPA.Long.Bout.Length=Mean.MVPA.Long.Bout.Length, Proportion.of.MVPA.Long.Bouts.greater.10=Proportion.of.MVPA.Long.Bouts.greater.10,Proportion.of.MVPA.Long.Bouts.greater.20=Proportion.of.MVPA.Long.Bouts.greater.20, Highest.MET.value.15s= Highest.MET.value.15s,Highest.MET.value.10min=Highest.MET.value.10min, Total.MET.hrs.Long.Bouts.and.Sporadic.mvpa= Total.MET.hrs.Long.Bouts.and.Sporadic.mvpa,Total.MET.hrs.Long.Bouts=Total.MET.hrs.Long.Bouts,table=table)\nreturn(out)\n\n}\n",
    "created" : 1450303778524.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2433728507",
    "id" : "639F457E",
    "lastKnownWriteTime" : 1450303805,
    "path" : "~/wear/R/MVPA_summary.R",
    "project_path" : "R/MVPA_summary.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "type" : "r_source"
}