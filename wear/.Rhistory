interval.length<-mvpa.sporadic.interval*60/60/60/24
interval.1min.start<-start.time+interval.length*(1:(num.1min.interval))
##################
mvpa.record.start.time<-c(start.time, interval.1min.start)
mvpa.record.end.time<-c(interval.1min.start,end.time)
################## if there is take off, they won't be in combine.original.pseudo.mat
combine.original.pseudo.mat<-do.call(rbind,sapply(1: length(mvpa.record.start.time),function(ll){
temp.mat<-subset(mvpa.1min.mat,mvpa.1min.mat[,1]+mvpa.1min.mat[,2]/24/60/60>mvpa.record.start.time[ll] & mvpa.1min.mat[,1]<mvpa.record.end.time[ll] )
if(nrow(temp.mat)==0) return (NULL)
if(temp.mat[nrow(temp.mat),1]+(temp.mat[nrow(temp.mat),2]/24/60/60)> mvpa.record.end.time[ll])  ###if this activity is the last one and it surpass the take off log time
{
temp.mat[nrow(temp.mat),4]<-temp.mat[nrow(temp.mat),4]*(mvpa.record.end.time[ll]-temp.mat[nrow(temp.mat),1])/(temp.mat[nrow(temp.mat),2]/24/60/60)
temp.mat[nrow(temp.mat),2]<- (mvpa.record.end.time[ll]-temp.mat[nrow(temp.mat),1])*24*60*60
}
if(temp.mat[1,1]<mvpa.record.start.time[ll])   ###if this activity is the first one and itis earlier than the take on log time
{
temp.mat[1,4]<-temp.mat[1,4]* (temp.mat[1,2]-(mvpa.record.start.time[ll]- temp.mat[1,1])*24*60*60)/temp.mat[1,2]
temp.mat[1,2]<-temp.mat[1,2]-(mvpa.record.start.time[ll]- temp.mat[1,1])*24*60*60
temp.mat[1,1]<-mvpa.record.start.time[ll]
}
return(cbind(temp.mat,ll))
}, simplify = F)  )
colnames(combine.original.pseudo.mat)<-c("date.time","Interval","ActivityCode", "METs","one.minute.interval")
############################################################
############################################################ step2 summary 1 min intervals
############################################################
one.minute.collection<-by(combine.original.pseudo.mat,combine.original.pseudo.mat$one.minute.interval,function(s)c(min(s$date.time),sum(s$METs)*(60/mvpa.sporadic.interval),unique(s$one.minute.interval),sum(s$Interval)  )) ###point 3
one.minute.mat<-do.call(rbind,one.minute.collection)
one.minute.mat<-subset(one.minute.mat,one.minute.mat[,3]!=0 & one.minute.mat[,4]>(60*mvpa.sporadic.interval*0.9) & one.minute.mat[,4]<(60*mvpa.sporadic.interval*1.1)     )  ### one.minute.mat[,4] is the true length, it may not be exactly 30 second, can have a few seconds bias
#########################
if(trunc(nrow(one.minute.mat)/(10/mvpa.sporadic.interval))==0)  {
ten.minute.vec<-rep(1,nrow(one.minute.mat))
if(nrow(one.minute.mat)==1) ten.minute.mat<- data.frame(t(c(one.minute.mat[1:length(ten.minute.vec),],ten.minute.vec)))
if(nrow(one.minute.mat)>1) ten.minute.mat<- data.frame(cbind(one.minute.mat[1:length(ten.minute.vec),],ten.minute.vec))
} else
{
ten.minute.vec<-rep(1:trunc(nrow(one.minute.mat)/(10/mvpa.sporadic.interval)),each=  (10/mvpa.sporadic.interval)    )    ##### 30s to 10 min ###point 4
ten.minute.mat<- data.frame(cbind(one.minute.mat[1:length(ten.minute.vec),],ten.minute.vec))
}
colnames(ten.minute.mat)<-c("date.time","mets","one.minute.interval","interval.length","ten.minute.interval")
############################################################
############################################################ step3 summary 10 min intervals
############################################################
#### if in 10 minutes, 8 minutes have METs>3, it is MVPA bout; if less than 8minutes, they are counted as mvpa sporadic.
is.mvpa<-function(s) if(s>=(8/mvpa.sporadic.interval)    ) return(1) else return(0)   ###point 5  ### this is for MVPA long bout
ten.minute.collection<- data.frame(do.call(rbind,by(ten.minute.mat,ten.minute.mat$ten.minute.interval,function(s)c(min(s$date.time), is.mvpa(length(which(s$mets>=3))), mean(s$mets),length(which(s$mets>=3)), abs(max(s$date.time)-min(s$date.time)-sum(s$interval.length[1:(length(s$interval.length)-1)])/24/60/60 )   ))))
colnames(ten.minute.collection)<-c("date.time","mvpa","mets","mvpa.sporadic","is.interval.valid")  #### is.interval.valid is to avoid the wear off during the day problem
ten.minute.collection<-subset(ten.minute.collection,is.interval.valid<0.003) ###if the interval has 5 minutes take off, we do not take it
############################################################
############################################################ step4 MVPA information
############################################################
#### total time
Total.MVPA.Long.Bout.time<-nrow(subset(ten.minute.collection,mvpa==1))/6  ###by hours
Total.MVPA.Sporadic.time<-sum(subset(ten.minute.collection,mvpa.sporadic>0 & mvpa!=1)$mvpa.sporadic )/(60/mvpa.sporadic.interval) ###by hours ###point 6
Total.MVPA.time<- Total.MVPA.Long.Bout.time+Total.MVPA.Sporadic.time
Total.light.time<- sum(temp.activity) /60/60-Total.MVPA.time
#### Long Bouts+Sporadic.time runs
Long.Bouts.and.Sporadic.run<- rle(ifelse( one.minute.mat[,2]>=3,1,0))
Total.Number.of.MVPA.Long.Bouts.and.Sporadic<-  length(which(Long.Bouts.and.Sporadic.run$values==1))
run.for.Long.Bouts.and.Sporadic.mvpa<- Long.Bouts.and.Sporadic.run$lengths[which(Long.Bouts.and.Sporadic.run$values==1)]/ (60/mvpa.sporadic.interval) ###by hours ###point 7
if(Total.MVPA.time==0)  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2<-0 else  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2<-100*length(run.for.Long.Bouts.and.Sporadic.mvpa[run.for.Long.Bouts.and.Sporadic.mvpa>1/30])/Total.Number.of.MVPA.Long.Bouts.and.Sporadic
if(Total.MVPA.time==0)  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5<-0 else  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5<-100*length(run.for.Long.Bouts.and.Sporadic.mvpa[run.for.Long.Bouts.and.Sporadic.mvpa>1/12])/Total.Number.of.MVPA.Long.Bouts.and.Sporadic
if(Total.MVPA.time==0)  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10<-0 else Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10<-100*length(run.for.Long.Bouts.and.Sporadic.mvpa[run.for.Long.Bouts.and.Sporadic.mvpa>1/6])/Total.Number.of.MVPA.Long.Bouts.and.Sporadic
#### Long Bouts Only runs
run.for.mvpa<-rle(ten.minute.collection$mvpa)
Total.Number.of.MVPA.Long.Bouts<-  length(which(run.for.mvpa$values==1))
temp.mvpa.long.bout<-run.for.mvpa$lengths[which(run.for.mvpa$values==1)]/6 ###by hours
if(Total.Number.of.MVPA.Long.Bouts==0) Mean.MVPA.Long.Bout.Length<-0 else Mean.MVPA.Long.Bout.Length<-mean(temp.mvpa.long.bout)
####
if(Total.Number.of.MVPA.Long.Bouts==0)  Proportion.of.MVPA.Long.Bouts.greater.10<-0 else  Proportion.of.MVPA.Long.Bouts.greater.10<-100*length(temp.mvpa.long.bout[temp.mvpa.long.bout>1/6])/Total.Number.of.MVPA.Long.Bouts
if(Total.Number.of.MVPA.Long.Bouts==0)  Proportion.of.MVPA.Long.Bouts.greater.20<-0 else  Proportion.of.MVPA.Long.Bouts.greater.20<-100*length(temp.mvpa.long.bout[temp.mvpa.long.bout>2/6])/Total.Number.of.MVPA.Long.Bouts
#### percentile is not meaningful, always too short
####if(Total.Number.of.MVPA.Long.Bouts==0)
#### {
####percentile.MVPA.Long.Bouts.time.5<- 0
####percentile.MVPA.Long.Bouts.time.25<- 0
####percentile.MVPA.Long.Bouts.time.50<- 0
####percentile.MVPA.Long.Bouts.time.75<- 0
####percentile.MVPA.Long.Bouts.time.95<- 0
#### } else {
####  Percentiles.of.MVPA.Long.Bout.Length.quantile<- quantile(temp.mvpa.long.bout, probs = c(0.05,0.25,0.5,0.75,0.95))
####percentile.MVPA.Long.Bouts.time.5<- Percentiles.of.MVPA.Long.Bout.Length.quantile[1]
####percentile.MVPA.Long.Bouts.time.25<- Percentiles.of.MVPA.Long.Bout.Length.quantile[2]
####percentile.MVPA.Long.Bouts.time.50<- Percentiles.of.MVPA.Long.Bout.Length.quantile[3]
####percentile.MVPA.Long.Bouts.time.75<- Percentiles.of.MVPA.Long.Bout.Length.quantile[4]
####percentile.MVPA.Long.Bouts.time.95<- Percentiles.of.MVPA.Long.Bout.Length.quantile[5]
####        }
####################################################
#################################################### MET.value
####################################################
Highest.MET.value.15s<- max(one.minute.mat[,2])
Highest.MET.value.10min<- max(ten.minute.collection[,3])
################################################ MET.value from MVPA
Total.MET.hrs.Long.Bouts.and.Sporadic.mvpa<- sum((one.minute.mat[,2]/60/60*one.minute.mat[,4])[one.minute.mat[,2]>=3])
Total.MET.hrs.Long.Bouts<- sum((subset(ten.minute.collection,mvpa==1))$mets/60*10)
table5<- c(88888888,Total.light.time,Total.MVPA.time, Total.MVPA.Long.Bout.time,Total.MVPA.Sporadic.time,Total.Number.of.MVPA.Long.Bouts.and.Sporadic,Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2,Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5,Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10, Total.Number.of.MVPA.Long.Bouts,Mean.MVPA.Long.Bout.Length, Proportion.of.MVPA.Long.Bouts.greater.10,Proportion.of.MVPA.Long.Bouts.greater.20, Highest.MET.value.15s,Highest.MET.value.10min, Total.MET.hrs.Long.Bouts.and.Sporadic.mvpa,Total.MET.hrs.Long.Bouts)
table5.label<- c("88888888","Total.light.time","Total.MVPA.time","Total.MVPA.Long.Bout.time","Total.MVPA.Sporadic.time","Total.Number.of.MVPA.Long.Bouts.and.Sporadic","Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2","Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5","Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10","Total.Number.of.MVPA.Long.Bouts","Mean.MVPA.Long.Bout.Length","Proportion.of.MVPA.Long.Bouts.greater.10","Proportion.of.MVPA.Long.Bouts.greater.20","Highest.MET.value.15s","Highest.MET.value.10min","Total.MET.hrs.Long.Bouts.and.Sporadic.mvpa","Total.MET.hrs.Long.Bouts")
###################################################
###################################################
################################################### For Sum Table
###################################################
temp.Summary.Statistics.Table<- t(c(table1,table2,table3,table4,table5))
colnames(temp.Summary.Statistics.Table)<-c(table1.label,table2.label,table3.label,table4.label,table5.label)
Summary.Statistics.Table<-rbind(Summary.Statistics.Table,temp.Summary.Statistics.Table)
}
}
setwd(folder.to.export.APST.csvfile.and.RDatafile)
if(week==0)write.table(Summary.Statistics.Table, file ="Summary.Statistics.Table.csv", append=T, sep=',', row.names = F)
if(week>0)write.table(Summary.Statistics.Table, file ="Summary.Statistics.Table.csv", append=T, sep=',',col.names=F, row.names = F)
rm(list= ls()[grep("APST", ls(),invert=T )])
}
eval(parse(text=paste("save.image('Combine.RData')",sep="")))
kk
record
#######################################################################################################
#######################################################################################################
library(reldist)  ###compute gini index
#######################################################################################################
########################################## Group Information ##########################################
#######################################################################################################
import.APST.csvfile.groups<- read.csv("C:\\Yukun\\Sarah'sProject_Haocheng\\STARTgroups.csv")
################################################ Set Folder     #####################################
folder.to.export.APST.csvfile.and.RDatafile<- "C:\\Yukun\\Sarah'sProject_Haocheng"
folder.to.import.APST.csvfile.week0<- "C:\\Yukun\\Sarah'sProject_Haocheng\\event files\\baseline"
folder.to.import.APST.csvfile.week3<- "C:\\Yukun\\Sarah'sProject_Haocheng\\event files\\three"
folder.to.import.APST.csvfile.week6<- "C:\\Yukun\\Sarah'sProject_Haocheng\\event files\\six"
folder.to.import.APST.csvfile.week9<- "C:\\Yukun\\Sarah'sProject_Haocheng\\event files\\nine"
folder.to.import.APST.csvfile.week12<- "C:\\Yukun\\Sarah'sProject_Haocheng\\event files\\twelve"
#############################################
for (www in c(0,3,6,9,12))
{
#### www=0
Summary.Statistics.Table<-c()
if(www==0) {week=0; setwd(folder.to.import.APST.csvfile.week0);takeoff.time<-read.csv("baseline.on.off.final.csv");bed.time<-read.csv("baseline.bed.final.csv")}
if(www==3){week=3; setwd(folder.to.import.APST.csvfile.week3);takeoff.time<-read.csv("week3.on.off.final.csv");bed.time<-read.csv("week3.bed.final.csv") }
if(www==6){week=6; setwd(folder.to.import.APST.csvfile.week6);takeoff.time<-read.csv("week6.on.off.final.csv");bed.time<-read.csv("week6.bed.final.csv") }
if(www==9){week=9; setwd(folder.to.import.APST.csvfile.week9);takeoff.time<-read.csv("week9.on.off.final.csv");bed.time<-read.csv("week9.bed.final.csv") }
if(www==12){week=12;setwd(folder.to.import.APST.csvfile.week12);takeoff.time<-read.csv("week12.on.off.final.csv");bed.time<-read.csv("week12.bed.final.csv") }
for (person in 1:2)
{
#######################################################read data
######## person<-1
id<-person
if(nchar(id)==1) id.char<-paste("0",id,sep="") else  id.char<-as.character(id)
#a<-try(eval(parse(text=paste("dat<-read.csv('APST",id.char,"W12_event.csv')",sep=""))))
if(week==0)a<-try(eval(parse(text=paste("dat<-read.csv('APST",id.char,"B_event.csv')",sep="")))) else a<-try(eval(parse(text=paste("dat<-read.csv('APST",id.char,"W",week,"_event.csv')",sep=""))))
if(class(a)=="try-error") next
#######################################################build record's begin and end time from log file/// May not be true!// trust data only
record<-subset(takeoff.time,takeoff.time$id==person)
###
if(nrow(record)==0)next
###
record.start.time<-c()
record.end.time<-c()
for (kk in 1:nrow(record))
{
temp.start.time<-as.numeric(as.POSIXlt(strptime(as.character(paste(as.character(record[kk,3] ),as.character(record[kk,4]))),"%m/%d/%Y %H:%M:%S"))+2209190400)/24/60/60
record.start.time<-c(record.start.time,temp.start.time)
temp.end.time<-as.numeric(as.POSIXlt( strptime(as.character(paste(as.character(record[kk,5] ),as.character(record[kk,6]))),"%m/%d/%Y %H:%M:%S")  )+2209190400)/24/60/60
record.end.time<-c(record.end.time,temp.end.time)
}
##########################################  match get up time with take on time/// if multiple take on time in a day, the second take on time is seen as get up time
#####list days take on
#####time.char<-as.numeric(format(as.POSIXlt(record.start.time*24*60*60, origin = ISOdatetime(1899,12,30,0,0,0) ),"%d"))
###
record.getup<-subset(bed.time,bed.time$id==person)
###
record.getup.time<-c()
record.sleep.time<-c()
for (kk in 1:nrow(record.getup))
{
temp.getup.time<-as.numeric(as.POSIXlt(strptime(as.character(paste(as.character(record.getup[kk,3] ),as.character(record.getup[kk,4]))),"%m/%d/%Y %H:%M:%S"))+2209190400)/24/60/60
record.getup.time<-c(record.getup.time,temp.getup.time)
temp.sleep.time<-as.numeric(as.POSIXlt(strptime(as.character(paste(as.character(record.getup[kk,5] ),as.character(record.getup[kk,6]))),"%m/%d/%Y %H:%M:%S"))+2209190400)/24/60/60
record.sleep.time<-c(record.sleep.time,temp.sleep.time)
}
#######################################################
##########################################  match get up time with take on time/// if multiple take on time in a day, the second take on time is seen as get up time
#######################################################
####################################################### Unify date structure  delete
print(is.numeric(dat$Time))
if(is.numeric(dat$Time)==F) ####if  is.numeric(dat$Time)==F, we need further modification of time in next step
{
ee<-as.character(dat$Time)
max.length<-max(nchar(ee))
print(max.length)
ee[nchar(ee)!=max.length]<-"#1899-12-30 00:00:00#"
#### use character type, may not be good
ee.new<- (as.numeric( as.POSIXlt( substr(ee, 2, max.length-1 )  )    )+2209190400)/24/60/60
#### use interval type, this is the best
start.ee<-  min(which(dat[,2]>0))-1
print(start.ee)
ee.new.int.type <-c( ee.new[1:((start.ee)-1)],ee.new[start.ee]+(dat$DataCount[start.ee:nrow(dat)]/10/24/60/60)  )
#### if interval type has large difference with character type, use character type
int.dif.char<-which(abs(ee.new-ee.new.int.type)>0.1 )
ee.new.int.type[int.dif.char]<-ee.new[int.dif.char]
####
dat<-cbind(ee.new.int.type,dat[,2:6])
}
dat<- dat[,1:6]  #### this works for both time good and bad data
#######################################################  delete wrong data, al records should between log time for take on and take off
#######################################################  For the case that start in log time but last long outside the log, we just leave the time in the interval
final.dat<-do.call(rbind,sapply( 1: length(record.start.time),function(ll){
temp.mat<-subset(dat,dat[,1]+dat[,3]/24/60/60>record.start.time[ll] & dat[,1]<record.end.time[ll] )
if(nrow(temp.mat)==0) return (NULL)
if(temp.mat[nrow(temp.mat),1]+(temp.mat[nrow(temp.mat),3]/24/60/60)> record.end.time[ll])  ###if this activity is the last one and it surpass the take off log time
{
temp.mat[nrow(temp.mat),6]<-temp.mat[nrow(temp.mat),6]*(record.end.time[ll]-temp.mat[nrow(temp.mat),1])/(temp.mat[nrow(temp.mat),3]/24/60/60)
temp.mat[nrow(temp.mat),3]<- (record.end.time[ll]-temp.mat[nrow(temp.mat),1])*24*60*60
}
if(temp.mat[1,1]<record.start.time[ll])   ###if this activity is the first one and itis earlier than the take on log time
{
temp.mat[1,6]<-temp.mat[1,6]* (temp.mat[1,3]-(record.start.time[ll]- temp.mat[1,1])*24*60*60)/temp.mat[1,3]
temp.mat[1,3]<-temp.mat[1,3]-(record.start.time[ll]- temp.mat[1,1])*24*60*60
temp.mat[1,1]<-record.start.time[ll]
}
return(temp.mat)
}, simplify = F))
if(length(final.dat)==0)next
#######################################################
####################################################### Dataset with Records
final.dat<-final.dat[,c(1,3,4,6)]
colnames(final.dat)<-c("date.time","Interval","ActivityCode", "METs")
if(is.numeric(dat[,1])==T) eval(parse(text=paste("APST",id.char,"week",week,"<-final.dat",sep=""))) else   next
#######################################################
####################################################### Summary Statistics
#######################################################
for (ll in 1: length(record.getup.time) )
{
## ll=1
temp.mat<-subset(final.dat,final.dat[,1]>record.getup.time[ll] & final.dat[,1]<record.sleep.time[ll] )
if(nrow(temp.mat)==0)next
###################################################
time.char<-as.POSIXlt(record.getup.time[ll]*24*60*60, origin = ISOdatetime(1899,12,30,0,0,0))
hour.char<-as.numeric(format(as.POSIXlt(temp.mat$date.time*24*60*60, origin = ISOdatetime(1899,12,30,0,0,0)),"%H"))
###
temp.sed<-subset(temp.mat,temp.mat$ActivityCode==0)$Interval
length.temp.sed<-length(temp.sed)
###################################################
###################################################
################################################### For Table part 1 evan_final_2_23
###################################################
### group
group.char<- as.character(subset(import.APST.csvfile.groups,id==person)$group)
if (length(group.char)==0) group.char<- NA                                                                    ##### some id does not have group
###
time.char<-as.POSIXlt(record.getup.time[ll]*24*60*60, origin = ISOdatetime(1899,12,30,0,0,0))
month<-as.numeric(format(time.char,"%m"))
day<-as.numeric(format(time.char,"%d"))
year<-as.numeric(format(time.char,"%Y"))
hours.worn.total<- sum(temp.mat$Interval)/60/60
hours.awake<- (record.sleep.time[ll]-record.getup.time[ll])*24
sed.hour<- sum(temp.sed) /60/60
stand.hour<- sum(subset(temp.mat,temp.mat$ActivityCode==1)$Interval) /60/60
step.hour<- sum(subset(temp.mat,temp.mat$ActivityCode==2)$Interval) /60/60
num.changes.from.sed.to.non.sed<- length.temp.sed
######## Code update here !
step.count.total<- 2*nrow(subset(temp.mat,temp.mat$ActivityCode==2))  ##### in the event file, one row with ActivityCode==2 means two steps
########
gini.index<- gini(temp.sed)
num.hour.over.3.METs<-  sum(temp.mat$Interval[(temp.mat$METs/temp.mat$Interval)*60*60>3])/60/60
MET.hours<- sum(temp.mat$METs)
valid.day<-ifelse( (hours.worn.total<10 & hours.worn.total/hours.awake>0.8 & step.count.total>200) | (hours.worn.total>=10 & step.count.total>200 ),1,0    )
dayofweek<-as.numeric(format(time.char,"%w"))
weekday.or.weekend<- ifelse( dayofweek!=0 & dayofweek!=6,1,0)
table1<-c(person,group.char,www,month,day,year,hours.worn.total,hours.awake,sed.hour,stand.hour,step.hour,num.changes.from.sed.to.non.sed,step.count.total,gini.index,num.hour.over.3.METs,MET.hours,valid.day,dayofweek,weekday.or.weekend)
table1.label<-c("id","group","week","month","day","year","hours.worn.total","hours.awake","sed.hour","stand.hour","step.hour","num.changes.from.sed.to.non.sed","step.count.total","gini.index","num.hour.over.3.METs","MET.hours","valid.day","dayofweek","weekday.or.weekend")
###################################################
################################################### For Table part 2  Doc to fill
###################################################
total.sed.time<-sed.hour
total.number.of.sed.bouts<-num.changes.from.sed.to.non.sed
mean.sed.bout.length<- mean(temp.sed) /60/60
prop.of.sed.time.greater.20min<- 100*length(temp.sed[temp.sed>20*60])/length.temp.sed
prop.of.sed.time.greater.60min<- 100*length(temp.sed[temp.sed>60*60])/length.temp.sed
prop.of.sed.time.greater.120min<- 100*length(temp.sed[temp.sed>120*60])/length.temp.sed
total.sed.time.greater.20min<- sum(temp.sed[temp.sed>20*60])/60/60
total.sed.time.greater.60min<- sum(temp.sed[temp.sed>60*60])/60/60
total.sed.time.greater.120min<- sum(temp.sed[temp.sed>120*60])/60/60
quantile.temp<-quantile(temp.sed, probs = c(0.05,0.25,0.5,0.75,0.95))/60/60
percentile.sed.time.5<- quantile.temp[1]
percentile.sed.time.25<- quantile.temp[2]
percentile.sed.time.50<- quantile.temp[3]
percentile.sed.time.75<- quantile.temp[4]
percentile.sed.time.95<- quantile.temp[5]
alpha.sed<- 1+ 1/mean(log(temp.sed/ min(temp.sed)))
gini.index.sed<- gini.index
prop.sed.time.6.12<- 100*sum(subset(temp.mat,temp.mat$ActivityCode==0 & hour.char>=6 & hour.char<12)$Interval) /(sum(subset(temp.mat,hour.char>=6 & hour.char<12)$Interval)+0.0001)   ###prevent this value is zero
prop.sed.time.12.18<- 100*sum(subset(temp.mat,temp.mat$ActivityCode==0 & hour.char>=12 & hour.char<18)$Interval) /(sum(subset(temp.mat,hour.char>=12 & hour.char<18)$Interval)+0.0001)
prop.sed.time.18.22<- 100*sum(subset(temp.mat,temp.mat$ActivityCode==0 & hour.char>=18 & hour.char<22)$Interval) /(sum(subset(temp.mat,hour.char>=18 & hour.char<22)$Interval)+0.0001)
table2<-c(88888888,total.sed.time,total.number.of.sed.bouts,mean.sed.bout.length,prop.of.sed.time.greater.20min,prop.of.sed.time.greater.60min,prop.of.sed.time.greater.120min,total.sed.time.greater.20min,total.sed.time.greater.60min,total.sed.time.greater.120min,percentile.sed.time.5,percentile.sed.time.25,percentile.sed.time.50,percentile.sed.time.75,percentile.sed.time.95,alpha.sed,gini.index.sed,prop.sed.time.6.12,prop.sed.time.12.18,prop.sed.time.18.22)
table2.label<-c("88888888","total.sed.time","total.number.of.sed.bouts","mean.sed.bout.length" ,"prop.of.sed.time.greater.20min","prop.of.sed.time.greater.60min","prop.of.sed.time.greater.120min","total.sed.time.greater.20min","total.sed.time.greater.60min","total.sed.time.greater.120min","percentile.sed.time.5","percentile.sed.time.25","percentile.sed.time.50","percentile.sed.time.75","percentile.sed.time.95","alpha.sed","gini.index.sed","prop.sed.time.6.12","prop.sed.time.12.18","prop.sed.time.18.22")
###################################################
################################################### For Table part 3  Sarah's table
###################################################
perc.sedentary<- 100*sed.hour/hours.worn.total
perc.stand<- 100*stand.hour/hours.worn.total
perc.step<- 100*step.hour/hours.worn.total
step.per.day<-step.count.total
break.per.day<-num.changes.from.sed.to.non.sed
break.rate<-break.per.day/sed.hour
MET.hour<- MET.hours
table3<- c(88888888,perc.sedentary,perc.stand,perc.step,step.per.day,break.per.day,break.rate,MET.hour)
table3.label<- c("88888888","perc.sedentary","perc.stand","perc.step","step.per.day","break.per.day","break.rate","MET.hour")
###################################################
################################################### Calculate Activity information
###################################################
### for standing and stepping, we have to combine the data
### since this is for activity, we take standing and stepping as the same activity
############### start and ends of each runs
temp.mat.for.activity<- temp.mat
temp.mat.for.activity$Activity[temp.mat.for.activity$Activity==1]<-2
end.pos<-cumsum(rle(temp.mat.for.activity$Activity)$lengths)
start.pos<-c(0,end.pos[1:(length(end.pos)-1)])+1
############### for each runs, handle the data
handle.runs<- sapply(1:length(end.pos),function(x,data.mat=temp.mat.for.activity)
{
select.data<-data.mat[start.pos[x]:end.pos[x],]
combine.data<- c(min(select.data$date.time),sum(select.data$Interval),max(select.data$Activity),sum(select.data$METs) )
return(combine.data)
}, simplify=F
)
############### combine each run
combined.temp.mat.for.activity<-data.frame(do.call(rbind,handle.runs))
colnames(combined.temp.mat.for.activity)<-c("date.time", "Interval", "ActivityCode","METs")
###############
###############Calculation
###############
###
temp.activity<-subset(combined.temp.mat.for.activity,combined.temp.mat.for.activity$ActivityCode==2)$Interval
###
length.temp.activity<-length(temp.activity)
total.number.of.activity.bouts<- length.temp.activity
mean.activity.bout.length<- mean(temp.activity) /60/60
prop.of.activity.time.greater.5min<- 100*length(temp.activity[temp.activity>5*60])/length.temp.activity
prop.of.activity.time.greater.10min<- 100*length(temp.activity[temp.activity>10*60])/length.temp.activity
prop.of.activity.time.greater.30min<- 100*length(temp.activity[temp.activity>30*60])/length.temp.activity
total.activity.time.greater.5min<- sum(temp.activity[temp.activity>5*60])/60/60
total.activity.time.greater.10min<- sum(temp.activity[temp.activity>10*60])/60/60
total.activity.time.greater.30min<- sum(temp.activity[temp.activity>30*60])/60/60
quantile.activity.temp<-quantile(temp.activity, probs = c(0.05,0.25,0.5,0.75,0.95))/60/60
percentile.activity.time.5<- quantile.activity.temp[1]
percentile.activity.time.25<- quantile.activity.temp[2]
percentile.activity.time.50<- quantile.activity.temp[3]
percentile.activity.time.75<- quantile.activity.temp[4]
percentile.activity.time.95<- quantile.activity.temp[5]
alpha.activity<- 1+ 1/mean(log(temp.activity/ min(temp.activity)))
gini.index.activity<- gini(temp.activity)
stepping.to.standing.ratio<- step.hour/stand.hour
table4<- c(88888888,total.number.of.activity.bouts,mean.activity.bout.length,prop.of.activity.time.greater.5min,prop.of.activity.time.greater.10min,prop.of.activity.time.greater.30min,total.activity.time.greater.5min,total.activity.time.greater.10min,total.activity.time.greater.30min,percentile.activity.time.5,percentile.activity.time.25,percentile.activity.time.50,percentile.activity.time.75,percentile.activity.time.95,alpha.activity,gini.index.activity,stepping.to.standing.ratio)
table4.label<- c("88888888","total.number.of.activity.bouts","mean.activity.bout.length","prop.of.activity.time.greater.5min","prop.of.activity.time.greater.10min","prop.of.activity.time.greater.30min","total.activity.time.greater.5min","total.activity.time.greater.10min","total.activity.time.greater.30min","percentile.activity.time.5","percentile.activity.time.25","percentile.activity.time.50","percentile.activity.time.75","percentile.activity.time.95","alpha.activity","gini.index.activity","stepping.to.standing.ratio")
####################
################################################################################################
###################################################Calculate MVPA information##################
################################################################################################
############################################################
############################################################ step 1, build 1min intervals.
############################################################
### The default X interval is 1 min/ the suggested intervals can be 30s, 10s
###
mvpa.sporadic.interval<- 1/4          ### 1 means 1 minute; 0.5 means 30 seconds; 1/6 means 10 seconds
mvpa.1min.mat<-temp.mat
start.time<-mvpa.1min.mat$date.time[1]
end.time<-  mvpa.1min.mat$date.time[nrow(mvpa.1min.mat)]
num.1min.interval<- trunc( (end.time-start.time)*24*60*60/(60*mvpa.sporadic.interval) )   ###point 1
#(end.time-start.time) != sum(temp.mat$Interval)/60/60/24 if there is take off
interval.length<-mvpa.sporadic.interval*60/60/60/24
interval.1min.start<-start.time+interval.length*(1:(num.1min.interval))
##################
mvpa.record.start.time<-c(start.time, interval.1min.start)
mvpa.record.end.time<-c(interval.1min.start,end.time)
################## if there is take off, they won't be in combine.original.pseudo.mat
combine.original.pseudo.mat<-do.call(rbind,sapply(1: length(mvpa.record.start.time),function(ll){
temp.mat<-subset(mvpa.1min.mat,mvpa.1min.mat[,1]+mvpa.1min.mat[,2]/24/60/60>mvpa.record.start.time[ll] & mvpa.1min.mat[,1]<mvpa.record.end.time[ll] )
if(nrow(temp.mat)==0) return (NULL)
if(temp.mat[nrow(temp.mat),1]+(temp.mat[nrow(temp.mat),2]/24/60/60)> mvpa.record.end.time[ll])  ###if this activity is the last one and it surpass the take off log time
{
temp.mat[nrow(temp.mat),4]<-temp.mat[nrow(temp.mat),4]*(mvpa.record.end.time[ll]-temp.mat[nrow(temp.mat),1])/(temp.mat[nrow(temp.mat),2]/24/60/60)
temp.mat[nrow(temp.mat),2]<- (mvpa.record.end.time[ll]-temp.mat[nrow(temp.mat),1])*24*60*60
}
if(temp.mat[1,1]<mvpa.record.start.time[ll])   ###if this activity is the first one and itis earlier than the take on log time
{
temp.mat[1,4]<-temp.mat[1,4]* (temp.mat[1,2]-(mvpa.record.start.time[ll]- temp.mat[1,1])*24*60*60)/temp.mat[1,2]
temp.mat[1,2]<-temp.mat[1,2]-(mvpa.record.start.time[ll]- temp.mat[1,1])*24*60*60
temp.mat[1,1]<-mvpa.record.start.time[ll]
}
return(cbind(temp.mat,ll))
}, simplify = F)  )
colnames(combine.original.pseudo.mat)<-c("date.time","Interval","ActivityCode", "METs","one.minute.interval")
############################################################
############################################################ step2 summary 1 min intervals
############################################################
one.minute.collection<-by(combine.original.pseudo.mat,combine.original.pseudo.mat$one.minute.interval,function(s)c(min(s$date.time),sum(s$METs)*(60/mvpa.sporadic.interval),unique(s$one.minute.interval),sum(s$Interval)  )) ###point 3
one.minute.mat<-do.call(rbind,one.minute.collection)
one.minute.mat<-subset(one.minute.mat,one.minute.mat[,3]!=0 & one.minute.mat[,4]>(60*mvpa.sporadic.interval*0.9) & one.minute.mat[,4]<(60*mvpa.sporadic.interval*1.1)     )  ### one.minute.mat[,4] is the true length, it may not be exactly 30 second, can have a few seconds bias
#########################
if(trunc(nrow(one.minute.mat)/(10/mvpa.sporadic.interval))==0)  {
ten.minute.vec<-rep(1,nrow(one.minute.mat))
if(nrow(one.minute.mat)==1) ten.minute.mat<- data.frame(t(c(one.minute.mat[1:length(ten.minute.vec),],ten.minute.vec)))
if(nrow(one.minute.mat)>1) ten.minute.mat<- data.frame(cbind(one.minute.mat[1:length(ten.minute.vec),],ten.minute.vec))
} else
{
ten.minute.vec<-rep(1:trunc(nrow(one.minute.mat)/(10/mvpa.sporadic.interval)),each=  (10/mvpa.sporadic.interval)    )    ##### 30s to 10 min ###point 4
ten.minute.mat<- data.frame(cbind(one.minute.mat[1:length(ten.minute.vec),],ten.minute.vec))
}
colnames(ten.minute.mat)<-c("date.time","mets","one.minute.interval","interval.length","ten.minute.interval")
############################################################
############################################################ step3 summary 10 min intervals
############################################################
#### if in 10 minutes, 8 minutes have METs>3, it is MVPA bout; if less than 8minutes, they are counted as mvpa sporadic.
is.mvpa<-function(s) if(s>=(8/mvpa.sporadic.interval)    ) return(1) else return(0)   ###point 5  ### this is for MVPA long bout
ten.minute.collection<- data.frame(do.call(rbind,by(ten.minute.mat,ten.minute.mat$ten.minute.interval,function(s)c(min(s$date.time), is.mvpa(length(which(s$mets>=3))), mean(s$mets),length(which(s$mets>=3)), abs(max(s$date.time)-min(s$date.time)-sum(s$interval.length[1:(length(s$interval.length)-1)])/24/60/60 )   ))))
colnames(ten.minute.collection)<-c("date.time","mvpa","mets","mvpa.sporadic","is.interval.valid")  #### is.interval.valid is to avoid the wear off during the day problem
ten.minute.collection<-subset(ten.minute.collection,is.interval.valid<0.003) ###if the interval has 5 minutes take off, we do not take it
############################################################
############################################################ step4 MVPA information
############################################################
#### total time
Total.MVPA.Long.Bout.time<-nrow(subset(ten.minute.collection,mvpa==1))/6  ###by hours
Total.MVPA.Sporadic.time<-sum(subset(ten.minute.collection,mvpa.sporadic>0 & mvpa!=1)$mvpa.sporadic )/(60/mvpa.sporadic.interval) ###by hours ###point 6
Total.MVPA.time<- Total.MVPA.Long.Bout.time+Total.MVPA.Sporadic.time
Total.light.time<- sum(temp.activity) /60/60-Total.MVPA.time
#### Long Bouts+Sporadic.time runs
Long.Bouts.and.Sporadic.run<- rle(ifelse( one.minute.mat[,2]>=3,1,0))
Total.Number.of.MVPA.Long.Bouts.and.Sporadic<-  length(which(Long.Bouts.and.Sporadic.run$values==1))
run.for.Long.Bouts.and.Sporadic.mvpa<- Long.Bouts.and.Sporadic.run$lengths[which(Long.Bouts.and.Sporadic.run$values==1)]/ (60/mvpa.sporadic.interval) ###by hours ###point 7
if(Total.MVPA.time==0)  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2<-0 else  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2<-100*length(run.for.Long.Bouts.and.Sporadic.mvpa[run.for.Long.Bouts.and.Sporadic.mvpa>1/30])/Total.Number.of.MVPA.Long.Bouts.and.Sporadic
if(Total.MVPA.time==0)  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5<-0 else  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5<-100*length(run.for.Long.Bouts.and.Sporadic.mvpa[run.for.Long.Bouts.and.Sporadic.mvpa>1/12])/Total.Number.of.MVPA.Long.Bouts.and.Sporadic
if(Total.MVPA.time==0)  Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10<-0 else Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10<-100*length(run.for.Long.Bouts.and.Sporadic.mvpa[run.for.Long.Bouts.and.Sporadic.mvpa>1/6])/Total.Number.of.MVPA.Long.Bouts.and.Sporadic
#### Long Bouts Only runs
run.for.mvpa<-rle(ten.minute.collection$mvpa)
Total.Number.of.MVPA.Long.Bouts<-  length(which(run.for.mvpa$values==1))
temp.mvpa.long.bout<-run.for.mvpa$lengths[which(run.for.mvpa$values==1)]/6 ###by hours
if(Total.Number.of.MVPA.Long.Bouts==0) Mean.MVPA.Long.Bout.Length<-0 else Mean.MVPA.Long.Bout.Length<-mean(temp.mvpa.long.bout)
####
if(Total.Number.of.MVPA.Long.Bouts==0)  Proportion.of.MVPA.Long.Bouts.greater.10<-0 else  Proportion.of.MVPA.Long.Bouts.greater.10<-100*length(temp.mvpa.long.bout[temp.mvpa.long.bout>1/6])/Total.Number.of.MVPA.Long.Bouts
if(Total.Number.of.MVPA.Long.Bouts==0)  Proportion.of.MVPA.Long.Bouts.greater.20<-0 else  Proportion.of.MVPA.Long.Bouts.greater.20<-100*length(temp.mvpa.long.bout[temp.mvpa.long.bout>2/6])/Total.Number.of.MVPA.Long.Bouts
#### percentile is not meaningful, always too short
####if(Total.Number.of.MVPA.Long.Bouts==0)
#### {
####percentile.MVPA.Long.Bouts.time.5<- 0
####percentile.MVPA.Long.Bouts.time.25<- 0
####percentile.MVPA.Long.Bouts.time.50<- 0
####percentile.MVPA.Long.Bouts.time.75<- 0
####percentile.MVPA.Long.Bouts.time.95<- 0
#### } else {
####  Percentiles.of.MVPA.Long.Bout.Length.quantile<- quantile(temp.mvpa.long.bout, probs = c(0.05,0.25,0.5,0.75,0.95))
####percentile.MVPA.Long.Bouts.time.5<- Percentiles.of.MVPA.Long.Bout.Length.quantile[1]
####percentile.MVPA.Long.Bouts.time.25<- Percentiles.of.MVPA.Long.Bout.Length.quantile[2]
####percentile.MVPA.Long.Bouts.time.50<- Percentiles.of.MVPA.Long.Bout.Length.quantile[3]
####percentile.MVPA.Long.Bouts.time.75<- Percentiles.of.MVPA.Long.Bout.Length.quantile[4]
####percentile.MVPA.Long.Bouts.time.95<- Percentiles.of.MVPA.Long.Bout.Length.quantile[5]
####        }
####################################################
#################################################### MET.value
####################################################
Highest.MET.value.15s<- max(one.minute.mat[,2])
Highest.MET.value.10min<- max(ten.minute.collection[,3])
################################################ MET.value from MVPA
Total.MET.hrs.Long.Bouts.and.Sporadic.mvpa<- sum((one.minute.mat[,2]/60/60*one.minute.mat[,4])[one.minute.mat[,2]>=3])
Total.MET.hrs.Long.Bouts<- sum((subset(ten.minute.collection,mvpa==1))$mets/60*10)
table5<- c(88888888,Total.light.time,Total.MVPA.time, Total.MVPA.Long.Bout.time,Total.MVPA.Sporadic.time,Total.Number.of.MVPA.Long.Bouts.and.Sporadic,Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2,Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5,Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10, Total.Number.of.MVPA.Long.Bouts,Mean.MVPA.Long.Bout.Length, Proportion.of.MVPA.Long.Bouts.greater.10,Proportion.of.MVPA.Long.Bouts.greater.20, Highest.MET.value.15s,Highest.MET.value.10min, Total.MET.hrs.Long.Bouts.and.Sporadic.mvpa,Total.MET.hrs.Long.Bouts)
table5.label<- c("88888888","Total.light.time","Total.MVPA.time","Total.MVPA.Long.Bout.time","Total.MVPA.Sporadic.time","Total.Number.of.MVPA.Long.Bouts.and.Sporadic","Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.2","Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.5","Proportion.of.MVPA.Long.Bouts.and.Sporadic.greater.10","Total.Number.of.MVPA.Long.Bouts","Mean.MVPA.Long.Bout.Length","Proportion.of.MVPA.Long.Bouts.greater.10","Proportion.of.MVPA.Long.Bouts.greater.20","Highest.MET.value.15s","Highest.MET.value.10min","Total.MET.hrs.Long.Bouts.and.Sporadic.mvpa","Total.MET.hrs.Long.Bouts")
###################################################
###################################################
################################################### For Sum Table
###################################################
temp.Summary.Statistics.Table<- t(c(table1,table2,table3,table4,table5))
colnames(temp.Summary.Statistics.Table)<-c(table1.label,table2.label,table3.label,table4.label,table5.label)
Summary.Statistics.Table<-rbind(Summary.Statistics.Table,temp.Summary.Statistics.Table)
}
}
setwd(folder.to.export.APST.csvfile.and.RDatafile)
if(week==0)write.table(Summary.Statistics.Table, file ="Summary.Statistics.Table.csv", append=T, sep=',', row.names = F)
if(week>0)write.table(Summary.Statistics.Table, file ="Summary.Statistics.Table.csv", append=T, sep=',',col.names=F, row.names = F)
#rm(list= ls()[grep("APST", ls(),invert=T )])
}
eval(parse(text=paste("save.image('Combine.RData')",sep="")))
record
kk
temp.getup.time
record.getup.time
####################################################### Unify date structure  delete
print(is.numeric(dat$Time))
ee
View(dat)
substr(ee, 2, max.length-1 )
print(start.ee)
ee.new.int.type
174/215
library(devtools)
install.packages(devtools)
install.packages("devtools")
install.packages("devtools")
devtools::create()
library(devtools)
library(roxygen2)
dat=read.csv(file="C:\\Yukun\\Sarah'sProject_Haocheng\\event files\\baseline\\sample data.csv",header=TRUE)
devtools::use_data_raw(dat)
save(dat,"sample.rda")
save(dat,file=
"sample.rda")
names(dat)
length(dat)
dim(dat)
load_all
load_all()
load_all()
library(wear)
attach(sampledata)
library(devtools)
library(roxygen2)
